# 1. Introduzione al gioco
Dr. Schwartz è un gioco di avventura in modalità punta e clicca con narrazione testuale degli eventi che accadono 
durante la partita. Il gioco è pensato per essere in modalità single-player e narra le peripezie di un rinomato 
professore di intelligenza artificiale che ha un segreto da svelare.

## 1.1 Tema principale
Il gioco è incentrato sul tema dell’intelligenza artificiale e tramite una simpatica avventura in un edificio 
futuristico e ultra tecnologico si affronta un tema dalla riflessione profonda e dai risvolti notevoli nella nostra 
società, ovvero l’autocoscienza di una macchina e le sue possibili implicazioni nel quotidiano.

## 1.2 Comandi e inizio partita
Per giocare e interagire con i vari elementi del gioco servono il mouse e la tastiera del pc. In particolare, con il 
mouse è possibile interagire con oggetti presenti nel gioco e con i personaggi, cliccando con il tasto destro del mouse 
su di un oggetto o su di un personaggio è possibile visualizzare un piccolo menù a tendina che mostra le possibili 
interazioni. Per gli oggetti il menù mostra l’opzione “osserva”, che permette di visualizzare una finestra di testo 
nella quale è presente la descrizione dell’oggetto in questione oppure l’altra opzione ove è presente “raccogli” che 
permette di spostare l’oggetto nella barra dell’inventario presente alla base dello scenario. Quest’ultimo mostra gli 
oggetti che il giocatore possiede e sul lato sinistro sono presenti due bottoni con il simbolo di frecce che servono a 
scorrere l’inventario, cliccandoci con il tasto sinistro del mouse, nel qual caso gli oggetti raccolti non siano tutti 
visualizzabili. Un oggetto presente nell’inventario può essere selezionato con il clic del tasto sinistro del mouse, 
una volta selezionato il riquadro che lo contiene cambia colore passando dal viola al fucsia acceso e una volta 
selezionato è possibile utilizzare l’oggetto cliccando su di un altro oggetto o su di un personaggio affinché si 
inneschi un effetto. Per il controllo degli spostamenti del personaggio è possibile utilizzare le frecce direzionali 
presenti sulla tastiera la cui digitazione provoca lo spostamento del personaggio da una stanza del gioco ad un'altra. 
I movimenti sono controllati, questo significa che non è possibile muoversi liberamente in una stanza ma è possibile 
solo passare di stanza in stanza. La possibilità di cambiare stanza nel gioco è messa in risalto da delle frecce 
presenti sul pavimento della stanza in cui si trova il giocatore, esse sono delle indicazioni che avvertono della 
possibilità di cambiare stanza premendo la freccia della tastiera orientata nello stesso verso. Durante tutto il gioco 
il giocatore incontra vari personaggi con i quali interagisce parlando, per poter parlare con un personaggio è 
sufficiente cliccare con il tasto destro del mouse sul personaggio desiderato e dal menù a tendina che si apre 
cliccare con il tasto sinistro sull’ opzione parla. Quando il personaggio inizia a parlare compare una finestra color
lilla contenente il testo del dialogo per poter proseguire nel dialogo si deve premere una volta il tasto spazio della 
tastiera. Le finestre di dialogo contengono solo due righe di testo, perciò, una volta lette si deve premere spazio
per proseguire nella lettura del testo.

All’avvio del gioco si apre una schermata di benvenuto con il titolo del gioco e quattro pulsanti contenenti le opzioni 
nuova partita, carica, impostazioni ed esci per iniziare si necessita cliccare con il tasto sinistro sul pulsante nuova 
partita, il quale provoca l’avvio del la scena iniziale del gioco. Il pulsante carica  serve nel momento in cui avendo 
salvato la partita in un dato momento del gioco si desidera riprenderla per continuare l’avventura in un altro momento. 
Quando la partita è iniziata premendo il tasto esc è possibile accedere al menù di pausa nel quale saranno disponibili 
sempre quattro opzioni rispettivamente continua per riprendere la partita, salva per salvare i dati del gioco, 
impostazioni ed esci per abbandonare la partita attualmente in corso. Attualmente il pulsante impostazione non ha alcuna
funzione.

## 1.3 Trama del gioco
Siamo nel 2025 e tre scienziati informatici dalle grandi ambizioni stanno lavorando al progetto della loro vita che 
segnerà il passo nella storia evolutiva dell’uomo. Hanno unito le loro menti per creare JDBC-20, un cyborg con le più 
avanzate tecnologie del momento sulle quali gli scienziati lavorano da anni. L’opportunità di dimostrare al mondo le 
loro capacità si presenta con il Global-AI 2025, un congresso scientifico incentrato sul AI tenutosi con cadenza 
quinquennale atto a decretare la migliore intelligenza artificiale esistente attualmente. Per decretarlo occorre che 
l’intelligenza artificiale superi un test. Per questa edizione il test consiste nel far valutare una AI da una AI a sua 
volta. Questo lo si ottiene facendo vivere a JDBC-20 la simulazione di quanto accaduto nella precedente edizione, il 
Global-AI 2020, e capire se è in grado non solo di non commettere lo stesso errore, ma persino risolvere il guaio 
causato da JDBC-15, appunto, la macchina da testare al Global-AI 2020.

In tale simulazione  il congresso è tenuto in un prestigioso e particolare edificio nel quale hanno sede i laboratori 
di ricerca dei tre informatici. JDBC-15 è la macchina che deve essere sottoposta a valutazione da parte JDBC-20 che 
crederà di essere il Dr. Schwartz, massimo esponente a livello mondiale di AI.
Durante la simulazione, diversi imprevisti metteranno JDBC-20 a dura prova, spingendo al massimo le proprie capacità 
intellettive nei diversi ambiti di problem solving, pianificazione e ragionamento. La struttura stratificata 
dell’edificio, infatti, è tale da presentare una sfida su ogni piano, il cui superamento è obbligatorio per il 
raggiungimento del piano successivo.

La simulazione inizia nella hall del piano terra, luogo in cui avvengono le presentazioni tra i tre scienziati ed il 
Dr. Schwartz. Terminate le presentazioni ci si sposta nella sala conferenze in cui JDBC-15 impazzisce e rapisce il 
cuoco portandolo con sé. Quindi i tre scienziati incaricano Schwartz di recuperare alcuni oggetti necessari per 
sconfiggere JDBC-15 e riuscire a spegnere definitivamente il server dal quale dipendono le funzionalità della macchina 
stessa. Contestualmente, Schwartz conosce Nikita, un inquietante tecnico dell’ascensore la cui apparizioni saranno una 
costante durante l’intera durata del gioco.

Inizia, a questo punto, la “scalata” dell’edificio. Vinte le sfide presenti nei piani MIST, ALU ed EBERT, e recuperati 
tutti gli oggetti richiesti, Schwartz può dirigersi verso il piano Server, ma l’ascensore porta il nostro protagonista 
su uno strano piano nel quale si terrà la lotta definitiva con JDBC-15, la cui sconfitta permetterà di liberare lo 
spaghetti-dipendente cuoco Luigi.

Dopo essere riuscito a capire come lasciare questo piano, Schwartz può finalmente raggiungere il piano Server dove può 
procedere allo spegnimento.

A questo punto uno strano avvenimento pone fine alla simulazione e risponde alle domande sospese.

## 1.4 Descrizione dell’ambientazione
L’edificio in cui ha sede il gioco si sviluppa su più piani ogni piano corrisponde ad uno specifico livello del gioco.

Il primo livello è quello del piano terra dove il gioco prende forma con la scena di benvenuto all’ingresso 
dell’edificio nella hall principale, dove i tre scienziati aspettano con ansia il Dottor Schwartz.

Alla sinistra ovvero a ovest avendo lo schermo di fronte è situata la cucina dell’edificio dalle strane pietanze. 
Alla destra della hall principale ovvero a est avendo lo schermo di fronte vi è la sala conferenze nella quale si svolge 
la conferenza in cui il cyborg dà di matto. 
Infine a nord della hall troviamo la sala PT-B ovvero la sala ascensore del piano terra che permette di avere accesso 
agli altri livelli del gioco nonché piani. 
Il primo piano dell’edificio è il MIST acronimo di Minimum Intelligence Signal Test, il piano ha un tema color arancio 
ed è incentrato sulla psicoemotività dell’intelligenza artificiale. 
L’ascensore apre le sue porte nella stanza MIST-A ovvero la stanza di ingresso al piano MIST la quale ha collegate a 
destra la stanza MIST-B che contiene una stampante 3D di ultima generazione, mentre a sinistra troviamo la stanza 
MIST-D, una stanza nella quale si tengono strani progetti su piante carnivore geneticamente modificate e dalle proprietà 
urticanti. A nord della stanza MIST-D troviamo la stanza MIST-C adibita a ricerche e analisi dei dati e affiancata a 
quest’ultima troviamo una specie di bagno in una piccola stanzetta situata a sinistra ovvero a ovest della sala 
MIST-C. 

Salendo troviamo il piano ALU sinonimo di Arithmetic Logic Unit, il piano ha le tonalità del blu e il tema 
centrale è la logica e la matematica. La prima sala che incontriamo è la ALU-A, la stanza dell’ascensore, che fa da 
ingresso al piano. Alla sua destra ed alla sua sinistra troviamo rispettivamente ALU-D e ALU-B.
La sala ALU-D è la stanza di ricerca e di elaborazioni di dati nella quale si testano nuovi processori dalle 
prestazioni sorprendenti, mentre la ALU-B è la relax room per staccare dai tediosi rumori del laboratorio. 

Al terzo piano troviamo il piano Ebert dal colore verde, il tema del piano è la biocompatibilità tra essere viventi e 
dispositivi elettronici capaci di elaborare software. A tal proposito il piano presenta due esperimenti che lasceranno 
con il fiato sospeso. Entrando nella sala dell’ascensore, la EBERT-A, troviamo una zona ristoro. A destra vi è
ELBERT-Briciola, la stanza ove si portano avanti gli esperimenti su varie cavie malcapitate. A sinistra della EBERT-A 
troviamo la sala EBERT-B una lussuosa sala relax che ha uno strano inquilino e un magnifico acquario. Infine a sud 
della EBERT-B troviamo la EBERT-Garden una stanza che racchiude un indoor-garden. Passato il piano ELBERT segue il piano
BUG nel quale si approda nella stanza BUG-A, a ovest di questa si trova la BUG-B e a ovest di quest’ultima è situata la 
BUG-C spostandosi dalla BUG-C verso ovest si ritorna nella BUG-A. L’ultimo piano dell’edificio è occupato da un'unica 
stanza, la stanza dei server che non ha altre stanze ad essa collegate.

# 1.5 Soluzione del gioco
!!!AVVERTENZE: QUESTA SEZIONE E' DEDICATA SOLO PER AI PIU’ PIGRI GIOCATORI AL MONDO!!!
Dallo scenario iniziale nella PT-B, terminate le presentazioni con i tre scienziati, si dove parlare con un cameriere 
che ci invita a cercare un ingrediente per avere in cambio un cocktail. Nota bene che se non si fornisce l’ingrediente 
non sarà possibile proseguire nel gioco. L’ingrediente in questione sono le cime di rapa che è possibile trovare nella 
cucina. Una volta individuate è sufficiente cliccare con il tasto destro e scegliere l’opzione raccogli per portarle 
nell’inventario.
Per consegnare al cameriere le cime di rapa appena raccolte, si dovrà selezionarle dall'inventario e successivamente 
cliccare sul cameriere con il tasto sinistro. Egli, a questo punto, ci consegna il “Cime on the beach”, un cocktail 
dal colore verde fluorescente che il personaggio principale Schwartz deve bere per proseguire nel gioco.

Una volta bevuto il drink è possibile entrare nella sala conferenza per poter parlare con Antonio, l’interazione con 
tale personaggio provoca lo scenario della presentazione di JDBC-20, il quale alla fine da di matto per un 
malfunzionamento e decide di uccidere il cuoco. Terminato lo scenario ci si può tornare a muovere per le stanze. 
Rientrando nella Hall principale il cameriere dà delle indicazioni da seguire, le quali fanno approdare il giocatore 
nella sala dell’ascensore dove i tre scienziati spiegano cosa succede e cosa far fare al giocatore per risolvere il 
malfunzionamento del cyborg. 

Cliccando sull’ascensore si fa la conoscenza di un personaggio molto buffo: Nikita. Si tratta del tecnico che ci 
accompagna per tutta la durata del gioco e risolve problemi tecnici correlati all’ascensore. 

Successivamente alla conoscenza del tecnico, l'ascensore diventa utilizzabile permettendoci di raggiungere il piano MIST.
Qui bisogna spostarsi nella stanza MIST-C dove è possibile raccogliere un guanto meccanico che serve ad aprire un 
armadio bloccato nella stanza MIST-D. L’ apertura dell’armadio fa sì che compaiano nella stanza due nuovi oggetti: 
il registratore, necessario per la battaglia finale con il cyborg JDBC-20 e un filamento per stampante 3D, il quale deve
essere usato per mettere in funzione la stampante che si trova nella stanza MIST-B. 
La stampante 3D permette di costruire dei tappi per orecchie indispensabili per l’uso del registratore.
Una volta che si sono recuperati i tappi compare nella stanza lo scienziato Nicolas. A questo punto, se consegniamo a 
Nicolas il GO-TO-SHOK, ci viene restituito con inserita la cassetta contenente la registrazione.
A questo punto è giunto il momento di tornare nella MIST-A per prendere l’ascensore, ma prima di poterlo utilizzare 
si deve passare un test psicologico con delle domande a risposta vero o falso selezionabili cliccando con il tasto 
sinistro del mouse sull'icona corrispondente alla risposta che si desidera dare.
Le risposte al test sono le seguenti :	
1- si, 2- no, 3- no, 4- si, 5- no, 6- si, 7- si, 8- no, 9- no, 10- si, 11- no, 12- no, 13- si, 14- no, 15- si, 15- no, 
16- no, 17- si, 18- no, 19- no, 20- no.

Preso l’ascensore esso ci porta al secondo piano ove è situato il livello ALU. 
Entrando in questo piano ci troviamo immediatamente nella stanza ALU-A dalla quale ci si deve spostare nella stanza 
ALU-D, la stanza dei computer in cui è possibile trovare un pc interagendo con il quale si inizia un mini gioco che
consiste nella risoluzione di semplici equazioni matematiche.
Le soluzioni ai tre enigmi sono le seguenti: 1, (3,2,1), 35.
Risolti gli enigmi, compare lo scienziato Diego che chiede al giocatore di portargli un caffè in cambio dell’AXC8, 
un dispositivo che serve nella battaglia finale con il cyborg. Per trovare il caffè il giocatore deve recarsi nella 
stanza ALU-B nella quale è situata un bottiglietta vuota che si deve riempire utilizzando il distributore dell’acqua 
presente nella stessa stanza. Riempita la bottiglietta, compare nella stanza una bottiglia piena d’acqua dal colore 
celeste più scuro che deve essere utilizzata per mettere in funzione la macchina del caffè. Ora, si può ottenere il 
caffè che si necessita portare allo scienziato del piano ALU. Ottenuto il caffè e porgendolo a Diego è possibile 
recuperare l’AXC8.
A questo punto il giocatore si deve dirigere all’ascensore, ma per poterlo utilizzare deve superare un altro mini gioco 
consistente nella risoluzione di un captcha, ovvero si deve riuscire a digitare correttamente una parola mostrata da 
un’immagine che si apre in una finestra.
Le seguenti parole sono le possibili soluzione del captcha: --------------------------

Terminato questo minigioco e preso l’ascensore si raggiunge la stanza EBERT-A del piano EBERT, dalla quale è possibile 
accedere alla stanza EBERT-B nella quale si deve interagire con il robot presente. 
Alla fine dello scenario si deve tornare nella sala EBERT-A dove il robot sblocca l’accesso alla EBERT-Briciola. 
Prima di recarsi in quest’ultima stanza è necessario passare per la EBERT-Garden nella quale si devono recuperare 
degli oggetti che servono per riuscire a placare Briciola, una simpatica cavia da laboratorio. Gli oggetti da recuperare
sono un fungo rosso, dei fiori di marijuana e una roccia dalle sembianze di una sfera-poké. 
Con questi oggetti è possibile recarsi nella EBERT-Briciola per affrontare Briciola. 
Interagendo con quest’ultimo, esso si trasforma in una creatura gigantesca. Per placare la sua ira, 
si deve usare, nel seguente ordine, i fiori di marijana, il fungo rosso e infine la sfera di roccia per catturarlo. 
Quando lo si è catturato compare una scheda memoria che serve al robot per recuperare la memoria e fornirci il 
cheat-sheet, un oggetto necessario per la battaglia finale con il robot. 
Fornita la memoria al robot, tuttavia, esso non ci dà quello di cui necessitiamo, ma ci fornirà preziosi indizi per 
risolvere l'enigma successivo. Bisogna dunque recarsi nuovamente nella stanza EBERT-Garden e calpestare l’erba colorata 
dell’aiuola destra del giardino nel seguente ordine: 
blue-giallo-rosso-verde.
La combinazione avvia uno scenario terminato il quale è possibile tornare dal robot per ricevere il prezioso cheat-sheet.
Ottenuto l’oggetto ci si deve recare nella stanza dell’ascensore e dirigersi al piano server, tuttavia accade un 
imprevisto: il piano al quale si approda è il BUG, uno strano piano nel quale si inizia la lotta con il cyborg JDBC-20. 
Arrivati nella stanza dell’ascensore, la BUG-A, parte uno scenario che in automatico stordisce il cyborg. 
Una volta stordito ci si deve spostare nella stanza BUG-B, nella quale si trova il cuoco. 
Qui inizia un nuovo scenario nel quale il cyborg, ripresosi dal primo attacco, torna alla carica per infierire sul 
cuoco Luigi. 
Quando lo scenario è terminato, si deve utilizzare in sequenza: il registratore per stordire il cyborg, l’AXC8 per 
hackerarlo e infine il cheat-sheet per spegnere il sistema operativo. 
Fatto ciò il cuoco ci ringrazia e torna in cucina al suo amato lavoro. 
A questo punto, per tornare nella sala dell’ascensore, occorrerà spostarsi dalla BUG-C di nuovo nella BUG-A. 
Si scopre però che tutte le porte posizionate a destra delle varie stanze sono bloccate e per proseguire ci si può 
spostare solo nella stanza a sinistra. Su questo piano infatti le stanze ruotano su se stesse, per cui arrivati alla 
fine della BUG-C se si prosegue si ritorna alla BUG-A, continuando a spostarsi tra le stanze e ritornando nella 
stanza BUG-C il cyborg apparentemente K.O. si riprende e si dà alla fuga. 
Nel farlo, lascia cadere un libro che si scopre essere il manuale di progetto di JDBC-20 ove viene indicato come 
disattivarlo. 
Per farlo si necessita arrivare al piano server per spegnere il computer centrale. Ritornando nella stanza BUG-A si 
trovano sulla parete dei foglietti contenenti una nota lasciata dal tecnico che ci dà indicazioni su come giungere al 
piano server. Per farlo è sufficiente prendere ancora una volta l’ascensore e arrivare al piano server.
Qui compariranno i tre scienziati che avviseranno il giocatore di non spegnere il server, ma per terminare il 
gioco si deve procedere allo spegnimento. Una volta spento il server parte lo scenario finale dai risvolti entusiasmanti
sul quale non sveleremo nulla dal momento che il gioco termina già con lo shut-down dei computer centrali.



# 2. Struttura del software e scelte implementative.

## 2.1 Scenari
Uno scenario è una sequenza di azioni programmabili che avvengono automaticamente all’interno del gioco. 
L’esecuzione degli scenari è gestita dal GameManager e possono essere creati all’interno del codice del gioco
oppure essere codificati all’interno di un file XML per poter essere caricati tramite la classe XmlParser. 
La classe utilizzata per rappresentare uno scenario è General.ActionSequence.
Ogni oggetto di ActionSequence corrisponde concettualmente ad una sequenza di runnable, affinché sia generale e 
ogni runnable contenuta all’interno di essa dovrà contenere una chiamata al metodo GameManage::ContinueScenario. 
Questo metodo permette di notificare al GameManager di notificare quando deve proseguire con l’esecuzione del runnable 
successivo. Questo è necessario in quanto l’ok per la continuazione dello scenario può non essere inviato direttamente 
dal runnable corrente, ma da un thread esterno, come ad esempio un input dato dal giocatore.
Il GameManager utilizza una pila. Quando qualcuno invia una chiamata al metodo start.Scenario, allora la action 
sequence passata come parametro viene pushata nella pila. Se lo scenario era già stato precedentemente eseguito e 
viene riusato, allora esso ripartirà dall’inizio. In seguito viene eseguita l’azione corrente dello scenario che si 
trova al top della pila. Quando viene chiamato il metodo continueScenario, possono accadere due cose:
1. o la pila contiene come top uno scenario non concluso, in tal caso si esegue la sua prossima azione
2. oppure il top è concluso, quindi lo si rimuove dalla pila e si controlla se il nuovo top non sia ancora concluso, 
in tal caso si esegue la sua prossima azione. Se invece era anch’esso concluso, si controlla il successivo, e così via, 
fino allo svuotamento della pila.

### 2.1.1 Creazione degli scenari: Parsing degli scenari da file xml
Il metodo loadScenario della classe XmlLoader costruisce una action sequence risultante dal parsing di un file xml. 
Il root tag del file xml deve essere <scenario>, al suo interno vi sarà un numero arbitrario di nodi xml con il tag 
<azione>. Ogni nodo <azione> contiene al suo interno almeno un nodo <method>, inoltre può contenere nodi con tag 
particolari seguendo la sintassi prevista dalla primitiva ((dare nome a primitiva)) specificata dal contenuto 
dell’elemento <method>.
Ogni xml di una stanza deve contenere all’interno dell’elemento stanza, obbligatoriamente, un elemento scenario: 
lo scenario di inizializzazione della stanza. Può essere eventualmente vuoto e viene utilizzato in genere per 
specificare i collegamenti tra le stanze o per aggiungere un game peace alla stanza stessa.
Consultare la documentazione delle “primitiva” per la sintassi.
Quando una stanza viene caricata per la prima volta nella partita (non salvataggio caricato da database), gli scenari 
di inizializzazione vengono eseguiti per intero. Mentre quando le stanze vengono caricate da database allora del suo 
scenario di inizializzazione vengono ignorate tutte le azioni tranne i metodi “setNorth”, “setSouth”, “setWest” e “setEast”.
L’inizializzazione delle stanze procede come una visita in profondità di un grafo, infatti appena viene eseguita 
un’azione qualsiasi che riporta uno dei quattro metodi elencati sopra, viene caricata la stanza oggetto e viene eseguito 
il relativo scenario di inizializzazione, a seguito dello scenario della prima. 

## 2.2 Salvataggi e Database
Il database GAME viene utilizzato per memorizzare in maniera persistente tutte le informazioni al momento del 
salvataggio, necessarie successivamente a ricostruire lo stato del gioco.

### 2.2.1 Tabelle
Nelle tabelle vengono memorizzate esclusivamente le informazioni che possono mutare durante il gioco e dunque non 
presenti all’interno dei file XML utili al caricamento.

Nella tabella ROOM vengono salvati:
- Nome della stanza
- Path del file XML che la descrive
- Path dello scenario onEnter che risulta impostato al momento del salvataggio

Nella tabella LOCKENTRANCE vengono salvate le coppie <room, punto cardinale> tali per cui l’entrata nella stanza da 
tale punto cardinale risulta bloccata.
Nota: le entrate non bloccate, essendo la maggior parte ed essendo impostate di default, non vengono memorizzate.

Nella tabella ITEM vengono salvati:
- Name
- State
- CanUse 

State e CanUse sono informazioni che possono variare durante il gioco.

Nella tabella GAMECHARACTER vengono salvati:
- Name
- State 

Nelle tabelle ITEMLOCATION e CHARACTERLOCATION vengono memorizzate le presenze e posizioni di, rispettivamente, 
Item e gameCharacter, all’interno delle stanze. Queste tabelle sono uguali, ma separate in quanto impossibile creare 
un vincolo di integrità referenziale verso più tabelle contemporaneamente.

Nella tabella INVENTORY vengono salvati i nomi dei PickupableItem presenti all’interno dell'inventario del giocatore 
al momento del salvataggio.

Utilizzo all’interno del gioco:

All’avvio del gioco, se il database non è presente (esempio: al primo avvio), esso viene creato.
Se il giocatore preme il tasto “continua” vengono, in ordine, caricate prima le stanze, ripristinando i loro 
collegamenti tramite i rispettivi file XML e bloccando le entrate specificate nella tabella LOCKENTRANCE, in seguito 
vengono caricati i GamePiece tramite i file oggetti.xml e personaggi.xml. Essi vengono quindi inseriti nelle stanze ed 
infine viene caricato l’inventario.
Se il giocatore preme il tasto “salva”, viene prima eliminato il contenuto del database, sovrascrivendo il precedente 
salvataggio, poi vengono salvate, in ordine, le informazioni su Room, GamePiece e l’inventario.

## 2.3 API REST
È stato utilizzato il servizio api fornito dal sito https://www.themealdb.com, il quale, in seguito ad una chiamata, 
restituisce un JSON che contiene le informazioni relative ad una ricetta casuale.
La classe RecipeRestClient è basata sull’utilizzo del framework fornito dalla libreria Jersey per effettuare la 
richiesta al server ed ottenere la relativa risposta.
Dal JSON contenente la risposta vengono prelevate le informazioni da utilizzare all’interno del gioco, quali la 
categoria della ricetta e gli ingredienti con le relative dosi.
In caso di insuccesso della chiamata, vengono utilizzati dei valori di default sostitutivi.


## 2.4 Eventi e Architettura del sistema
Il GameManager è una classe adibita alla gestione di strutture dati fondamentali per far funzionare il gioco. 
Esso contiene variabili e costanti utilizzati da diverse classi per diversi scopi.
Ad esempio, blockSize è il numero di pixel che costituisce il lato di un blocco, oppure il riferimento al mainFrame 
del gioco.
Contiene riferimenti a tutti i GamePiece e Room caricati in memoria e gestisce lo stack degli scenari. 
Alla costruzione di un nuovo GamePiece o di una nuova Room, essi vengono automaticamente registrati rendendo possibile 
il loro utilizzo da parte di tutti i metodi di ogni package riferendosi per nome. È dunque importante che non vi siano 
più GamePiece o Room con lo stesso nome.

## 2.4.1 Sezione GAMESTATE (forse da unire sopra)
Un GameState è uno stato in cui si può trovare il gioco e determina quali azioni sono possibili e quali no. 
Ad esempio nello stato “palying” il giocatore può liberamente muoversi all’interno delle stanze ed interagire con 
oggetti e personaggi, mentre nello stato “textBar” non sarà possibile effettuare nessuna di queste interazioni, ma il 
giocatore potrà unicamente premere il tasto Barra Spaziatrice per chiudere la text-bar (mandando avanti il gioco, 
che potrebbe tornare allo stato playing). Per tale motivo abbiamo implementato i listener di tastiera e mouse 
(rispettivamente GameKeyListener e GameMouseListener) in modo tale che questi siano attivi e funzionino solo in un 
determinato gameState, denominato targetState.

## 2.5 Listener
Alcuni listener vengono creati staticamente dalla classe GameState: sono listener che operano su tutto il frame di 
gioco e corrispondono a comandi ben definiti, ad esempio le frecce direzionali utilizzate per cambiare stanza nello 
stato “playing” oppure la barra spaziatrice per chiudere la text-bar.
Esistono inoltre listener creati dinamicamente sul gameScreen che corrispondono a diversi elementi nel gioco, ve n'è 
almeno uno per ogni gamePiece (in quanto deve essere almeno possibile premere il tasto destro sul personaggio e 
mostrare il menu con le possibili interazioni con esso).
La creazione di queste liste avviene nel GameScreenPanel.
Per il cambio di stato viene mantenuta una variabile statica che identifichi lo stato corrente del gioco. 
Il metodo changeState permette di cambiare il suo valore e ha la key word “synchronize”, così come il metodo getState, 
in quanto lettura e scrittura dello stato possono avvenire su thread diversi (ad esempio, il thread di un’animazione di 
movimento all’inizio imposta il gameState a “moving”).

Gli elementi di gioco hanno due rappresentazioni:

- la rappresentazione di dominio in cui possono essere pensati come entità e ciò riguarda il package entity. 
I metodi e le interazioni tra le classi di questo package non fanno in alcun modo riferimento all’interfaccia che viene 
utilizzata per giocare. Sono dunque indipendenti dall’interfaccia ed esprimono unicamente i concetti e gli oggetti 
“fisici” del gioco. Tuttavia bisogna trovare un modo per far sì che essi abbiano una rappresentazione nella User 
Interface e bisogna aver stabilito precise regole di interazione in modo che l’input dell’utente tramite UI abbia 
effetti sulle entity, mentre aggiornamenti sulle entity siano correttamente propagati nelle loro rappresentazioni
relativamente alla user interface. Per questo coordinamento è stato pensato un sistema ad eventi, creando una classe 
astratta generica GameEvent che viene specializzata tramite le sue sottoclassi in modo tale che gli oggetti entity, 
quando aggiornati, generino eventi specifici e li inviino alla classe EventHandler, la quale si occupa di distinguere i 
vari tipi di eventi e di delegare a classi executor il compito di aggiornare in modo coerente con l’accaduto la User 
Interface.
Tali executors sono gli unici ad avere riferimento al mainFrame in modo tale da essere l’unico collegamento 
entity -> gui.

- la rappresentazione di input (gui -> entity) è possibile grazie alla classe PopMenuManager. 
Tramite il metodo addPieceOnScreen della classe GameScreenPanel, quando viene aggiunta la label con lo sprite di un 
GamePiece, viene creato un listener per il tasto destro che prevede la chiamata al metodo showMenu di PopMenuManager, 
passando sia il GamePiece che la label corrispondente. Il PopMenuManager crea un menu contestuale aggiungendo vari tasti 
corrispondenti alle varie interazioni possibili, in base alla classe effettiva del GamePiece passato. Infatti crea 
staticamente delle Action per ogni interazione possibile con qualsiasi GamePiece, in modo tale che cliccando sul tasto 
corrispondente venga eseguito il metodo relativo all’interazione per GamePiece sul quale si è cliccato.
Ad esempio, se il GamePiece è un’istanza di Item verrà abilitata una useAction in modo tale che venga chiamato il 
metodo Use dell’oggetto della classe Item.

## 2.6 Entity
Le classi del package entity rappresentano i principali elementi del dominio di gioco, i quali non dipendono
dall’interfaccia grafica.
In realtà questo package comprende ulteriori tre packages (entity.characters, entity.items, entity.rooms) i quali 
esistono solo per un fattore di ordine e pulizia nella struttura del codice.
Si riporta di seguito il diagramma delle classi di questi packages, in quanto si ritiene un aspetto cardine per la 
comprensione del dominio di gioco.

---- diagramma delle classi 


### 2.6.1 GamePiece
Un oggetto della classe astratta *GamePiece* rappresenta un qualsiasi elemento fisico del gioco che ha uno sprite e può 
essere presente all’interno di una stanza, in pratica un oggetto o un personaggio. La classe è astratta in quanto ogni 
oggetto deve necessariamente estendere una delle sottoclassi dirette (`Item` e `GameCharacter`).
- Ogni GamePiece ha un nome univoco ed uno stato, ovvero una stringa utilizzata per 
far si che un GamePiece abbia comportamenti diversi a seconda del suo valore.
- Un GamePiece può essere creato fornendogli un'immagine che costituirà il suo sprite principale, oppure uno sprite 
sheet descritto da un relativo file JSON. In questo ultimo caso, lo sprite principale viene ricavato cercando nel json 
l'oggetto il cui nome è pari a quello del GamePiece.
- Un GamePiece ha una posizione nella stanza in cui esso è contenuto: questa posizione è misurata in blocchi 
(vedi `BlockPosition` di `Room`) e corrisponde sempre alle coordinate del blocco in basso a sinistra del GamePiece
(considerando il fatto che il blocco in alto a sinistra ha coordinate (0,0).
- Presenta le seguenti liste di immagini: 
  - Immagini `leftMovingFrames`, utilizzate per le animazioni di movimento verso sinistra
  - Immagini `rightMovingFrames`, utilizzate per le animazioni di movimento verso destra
  - Immagini `animateFrames`, utilizzate per le animazioni personalizzate (metodi `animate` e `animateReverse`)
  - Immagini `perpetualAnimationFrames`, utilizzate per l'animazioni perpetua personalizzata.

Le prime due liste di default conterranno solamente lo sprite principale. Per questo motivo, quando il GamePiace si 
muove sullo schermo lo sprite non cambia.
Per la terza lista l'inizializzazione avviene chiamando il metodo `initAnimateFrames`, fornendo i path dello sprite-sheet 
del JSON. I frame vengono cercati tramite oggetti JSON con chiavi del tipo "animate1", "animate2"...
Se questi non vengono trovati allora cerca gli oggetti json le cui chiavi sono "\[name]animate1", "\[name]animate2", ...
Per la quarta lista l'inizializzazione avviene chiamando il metodo `initPerpetualAnimationFrames`, fornendo i path 
dello sprite-sheet del JSON. I frame vengono cercati tramite oggetti JSON con chiavi numerate ed incrementali.

### 2.6.2 Item
Item è un GamePiece il cui sprite viene caricato dallo sprite-sheet `oggetti.png` e relativo JSON e presenta:
- Una descrizione
- Un'interazione “usa” specializzata: il nome di tale azione può essere personalizzato, così come il suo effetto.
Ad ogni diverso stato in cui si trova l'item corrisponderà un diverso scenario all'esecuzione dell'interazione "usa":
tali informazioni sono contenute nel file "oggetti.xml".

Implementando l’interfaccia Osservable, un Item avrà associato l’interazione "osserva", il cui effetto è mostrare la 
descrizione dell’oggetto.

#### 2.6.3 PickupableItem
Un `PickupableItem` è un item che può essere raccolto e inserito nell’inventario. Quando è nell'inventario offre
l'interazione "useWith": può cioè essere utilizzato assieme ad un GamePiece presente sullo schermo. Questa interazione 
si esegue selezionando il PickupableItem e successivamente premendo il tasto sinistro sul GamePiece con cui si vuole interagire.
Secondo la sintassi spiegata in `oggetti.xml` è possibile impostare il GamePiece target dell’azione useWith e lo stato 
in cui deve essere il target affinché lo scenario corrispondente all’interazione venga eseguito.
Viene specificato inoltre lo stato al quale deve essere impostato il target al termine dell'interazione. 
È anche possibile specificare se il PickupableItem rimarrà nell'inventario in seguito all'utilizzo oppure dovrà essere 
rimosso.

#### 2.6.4 DoorLike
Un oggetto della classe `DoorLike` è un item le cui funzionalità sono assimilabili a quelle di una porta (infatti implementa 
l’interfaccia Openable).
- È possibile impostare uno scenario da eseguire all'interazione "open" che verrà eseguito se l'oggetto si trova in
particolare stato. Vi è uno stato riservato, ovvero "canOpen", durante il quale lo scenario eseguito all'interazione
"open" sarà l’effettiva apertura dell'oggetto DoorLike. 
- Non è invece possibile impostare uno scenario personalizzato per l’interazione Close, che risulterà sempre nella 
chiusura dell'oggetto doorLike.

La creazione degli oggetti della classe DoorLike prevede il recupero e l'impostazione dello sprite tramite i file 
`porte.png` e nel file JSON corrispondente, all’interno del quale viene cercato l'oggetto JSON la cui chiave è pari al 
nome dell'oggetto DoorLike in fase di costruzione.

Ogni oggetto DoorLike presenta due liste d'immagini:
- Immagini `openFrames`, utilizzate per l'animazione di apertura dell'oggetto DoorLike
- Immagini `closeFrames`, utilizzate per l'animazione di chiusura dell'oggetto DoorLike


Queste liste sono inizializzate durante la creazione dell'oggetto DoorLike, ricercando nel file JSON gli oggetti JSON 
con chiavi del tipo "\[name]Open1", "\[name]Open2", ..., e un oggetto JSON con chiave "\[name]Closed".


--------------------------------------------
Per ogni oggetto della classe DoorLike vi sono le interazioni "Open" e "Close", che sono unificate nel
menu contestuale.
--------------------------------------------



### 2.6.3 GameCharacter
I `GameCharacter` sono GamePiece che rappresentano i personaggi all’interno del gioco.
Ogni GameCharacter che viene creato utilizzando uno sprite-sheet ed un file JSON associato inizializza i frame di 
movimento `leftMovingFrames` e `rightMovingFrames` nel seguente modo (si riporta un esempio per i primi):
- Cerca oggetti json "leftMoving1", "leftMoving2", ..., dove name è il nome del GameCharacter;
- Se questi non sono trovati cerca oggetti json "\[name]leftMoving1", "\[name]leftMoving2", ...;
- infine aggiunge come primo frame lo sprite principale del GameCharacter.

Il file JSON deve anche contenere la voce “speaking” per indicare lo sprite che contribuisce a realizzare 
l’animazione del personaggio che parla. Inoltre un GameCharacter prevede anche un frameSpeaking che viene inizializzato 
come segue:
- Cerca nel json relativo allo sprite-sheet l'oggetto "speaking";
- Se questo non è presente cerca l'oggetto "\[name]speaking", dove \[name] è il nome del GameCharacter; 
- se neanche questo è presente allora esegue l'inizializzazione di default.


### 2.6.4 NPC
Un NPC è un non-playable-character, ovvero un GameCharacter che non può essere utilizzato dal giocatore. 
Esso offre l’interazione “parla”, al verificarsi della quale verrà stampata sulla text-bar una frase oppure scenario 
impostati nel file xml (a seconda dello stato in cui si trova l’npc).

### 2.6.5 PlayingCharacter
`PlayingCharacter` è una classe i cui oggetti rappresentano il personaggio giocante ed implementa il pattern Singleton, 
infatti i dati sul player non sono presenti all’interno del file xml, ma il giocatore viene creato staticamente 
all’inizio del gioco e non possono essere creati altri PlayingCharacter se non per un’eccezione, ovvero il metodo 
makePlayerFinalForm il quale sostituisce il personaggio giocante con uno dallo stesso nome ma non uno sprite diverso 
(necessario per la trama del gioco).

Un oggetto PlayingCharacter possiede un inventario, ovvero una struttura dati (attualmente una lista) che contiene un 
certo numero di PikupableItem. Notare che tale inventario ha una diretta rappresentazione grafica nella classe 
InventoryPanel e l’inventario del PlayingCharacter quando viene aggiornato, notifica tramite InventoryEvent 
l’inventory panel il quale a sua volta modifica la visualizzazione delle icone degli oggetti.

### 2.6.6 Rooms
Un oggetto `Room` è una stanza del gioco ed è identificata da un nome (invisibile al giocatore), può possedere fino a 
quattro collegamenti, uno per ogni punto cardinale, con altre stanze. Ad ogni stanza è associato un file XML che 
contiene tutte le informazioni statiche, come ad esempio il path dell’immagine di background o il path della musica 
di sottofondo.

Ogni room possiede un proprio pavimento, ovvero un oggetto di tipo RoomFloor e una posizione di default alla quale 
posizionare il personaggio giocante.

Può essere impostato uno scenario da avviare quando il giocatore entra nella stanza e le entrate possono essere 
bloccate o sbloccate. Ogni stanza inoltre mantiene i riferimenti a tutti i pezzi presenti e relative posizioni.

Ad ogni room è associato un file JSON con la seguente struttura:
- Deve avere width e height, un json array chiamato “pavimento” che contiene oggetti json con dentro “left”, “top”, 
“width”, “height”, che descrivono un rettangolo specificandone l’angolo in alto a sinistra e le dimensioni.
- Ostacoli, un json array che contiene oggetti descritti come sopra.
- Un oggetto DefaultPosition che contiene X e Y
- Per ogni entrata nella stanza, un oggetto con nome punto_cardinaleArrow (es. northArrow) contenente a sua volta X e Y.

#### 2.6.6 BlockPosition
Tutte le posizioni, le coordinate e le dimensioni relative ai GamePiece e alle Room sono espresse in blocchi: un blocco 
corrisponde ad un tile nell’immagine della stanza e le coordinate in una qualsiasi stanza si contano considerando 
l’angolo in alto a sinistra della stanza, avente coordinate spaziali (0,0) ed incrementando le ascisse da sinistra 
verso destra e le ordinate dall’alto verso il basso.

Notare che, dal momento in cui tali coordinate sono logiche e non fisiche, non hanno alcuna dipendenza dallo schermo 
(quindi rendono i dati portabili) e risulta molto semplice lavorarci.
Sarà compito della classe GameScreenManager la conversione da block position ad abs position 
(vedi Sezione GameScreenManager).


### 2.7 RoomFloor
Un oggetto di RoomFloor rappresenta il pavimento di una stanza, la cui inizializzazione è possibile tramite i dati 
contenuti nel json della stanza alle voci “pavimento” e “ostacoli”. Il pavimento è una forma data dalla composizione 
dei rettangoli descritti nel json del pavimento, all’interno della quale il personaggio giocante può muoversi. Ci sono 
però ulteriori rettangoli dati dalla voce ostacoli che rappresentano aree del pavimento su cui il giocatore non può 
muoversi. Ciononostante attualmente l’utilizzo del RoomFloor è parziale in quanto non è presente un algoritmo di 
movimento che ricalcoli il percorso da un punto di partenza ad uno di arrivo tenendo conto degli ostacoli ed 
aggirandoli. Attualmente viene utilizzato il metodo getNearestPlacement di RoomFloor per far sì che anche se dovesse 
essere impostato il movimento del giocatore in un punto in cui lo sprite non entra perfettamente allora questo viene 
comunque posizionato, occupando la posizione più vicina che è possibile occupare.


### 2.8 Suoni
Per i suoni è stata utilizzata la libreria javax.sound.sampled, la quale permette di riprodurre file in formato wav. 

Si distinguono tre tipologie di audio nel gioco, che corrispondono a modalità di riproduzione accettate dalla classe 
SoundHandler:
- music, modalità utilizzata per riprodurre le musiche di sottofondo delle stanze le quali sono messe a loop e vengono 
stoppate solamente al passaggio in una stanza in cui la musica impostata è diversa.
- sound, modalità utilizzata per riprodurre suoni di gioco generati da input del giocatore, attualmente i suoni di questo
tipo vengono utilizzati: alla chiusura della text-bar, premendo la barra spaziatrice, quando si passa il mouse su un 
tasto del menu, quando viene aggiunto un oggetto all’inventario o quando viene eseguita l’animazione di una emoji. 
Tali suoni hanno dei path memorizzati nel SoundHandler, per cui le relative clip sono registrate staticamente, 
eliminando l’esigenza di  aprire i file ogni qualvolta devono essere riprodotti.
- scenario sound, modalità dedicata all’azione “playScenarioSound” degli scenari, la quale fa sì che ogni volta che 
venga aperto il file specificato dall’azione, viene utilizzata la clip scenarioSound inizializzata staticamente e 
alla quale è aggiunto un lineListener che all’evento di stop (quindi quando termina l’audio riprodotto dall’azione 
dello scenario) invoca il metodo GameManager.contiueScenario.

Nota: Il listener è obbligatorio in quanto non è possibile avere il controllo sul thread dell’audio in riproduzione e 
quindi non avremmo altro modo per eseguire tale chiamata al momento in cui termina la riproduzione.

### 2.9 Animazioni
Il package animazioni contiene la classe astratta animation e le sue implementazioni:
- stillAnimation, rappresenta un’animazione in cui cambia lo sprite di un GamePiece o di una qualsiasi JLabel, ma non 
la sua posizione.
- movingAnimation, rappresenta un’animazione in cui cambia la posizione di una JLabel e può cambiare contestualmente 
anche la sua icona.
- perpetualAnimation, sottoclasse di stillAnimation e rappresenta un’animazione in cui non cambia la posizione di una 
JLabel ma la stessa animazione viene ripetuta in loop all’infinito finché non viene interrotta da un qualche evento 
esterno.

Ogni animazione presenta un thread dedicato su cui viene eseguita, permettendo quindi l’esecuzione di più animazioni 
contemporaneamente e l’esecuzione di animazioni in modo indipendente dall’interazione del giocatore con il gioco.

#### 2.9.1 Animation
Ogni animazione interviene su una JLabel presente sullo schermo e consiste nell’alternarsi di una certo numero di frames 
(immagini). Possono essere impostati i millisecondi da attendere alla fine dell’esecuzione dell’animazione e 
successivamente alla creazione viene eseguita chiamando il metodo start (solo in quel momento viene chiamato il thread 
dedicato).

L’esecuzione dell’animazione (ovvero il metodo run dell’AnimationThread) segue il design pattern del template metod. 
Infatti questa classe astratta implementa il run come una chiamata al metodo astratto execute seguito da thread.sleep 
per il numero dei millisecondi impostato ed infine chiama il metodo terminate anch’esso astratto. Le sottoclassi 
implementeranno tali metodi astratti in modo tale da specializzare il modo in cui viene aggiornata la JLabel da animare 
e le azioni da eseguire al termine.

#### 2.9.2 StillAnimation
Una stillAnimation è l’animazione di una JLabel in cui questa cambia icona ma non posizione. È possibile impostare il 
delay in millisecondi tra la visualizzazione di un frame ed il successivo e se tale delay vi è anche prima dell’inizio 
dell’animazione.

L’esecuzione di tale animazione prevede innanzitutto un cambio di GameState nello stato moving e in seguito 
un’iterazione su tutti i frame in cui si aspetta il delay impostato e si aggiorna l’icona della Label con il frame 
successivo. È possibile impostare una runnable da eseguire al termine dell’animazione e alla fine il thread dedicato 
all’animazione manda avanti lo scenario attraverso la chiamata a GameManager.continueScenario.

La classe mette inoltre a disposizione una static factory per poter creare animazioni personalizzate tramite sprite 
sheet e json in cui vengono fornite le informazioni sulla posizione dei vari frame (nel json oggetti con chiave 
“nomeAnimazione_Numero”, es. Esplosione1, Esplosione2, …).

Utilizzi:
- Animazione alla pressione dei tasti dell’inventario
- Creazione di effetti animati personalizzati, relativi a GamePiece, che utilizzano JLabel sovrapposte a quelle dei 
- GamePiece (GameScreenPanel.StackAnimation)
- Nelle interazioni con gli item che includono un’animazione (es. apertura porte)
- Al metodo animate ed animateReverse dei GamePiece

#### 2.9.3 MovingAnimation
Una movingAnimation è un’animazione in cui una JLabel cambia posizione, cambiando eventualmente icona. Per la JLabel è 
possibile impostare posizione iniziale, posizione finale, i frame da alternare in loop durante tutta l’esecuzione 
dell’animazione e la velocità alla quale questa deve essere eseguita.
Sulla base dei parametri ricevuti calcola una sequenza di coordinate equidistanti in cui la JLabel viene posizionata 
ad ogni iterazione nell’esecuzione. Tali posizionamenti procedono partendo dalla posizione iniziale ed avvicinandosi 
verso la posizione finale.

Nota: il calcolo delle coordinate intermedie viene fatto tramite le abs position e il numero di queste coordinate 
intermedie dipende dalla variabile statica FPS della classe (attualmente impostato a 60) e dalla velocità impostata 
per l'animazione. Il caso di lag, considerare di abbassare tale variabile. Anche il delay tra iterazioni successive 
nell’esecuzione dell’animazione viene calcolato sulla base di questi dati.

Ogni 10 cambi di coordinate intermedie viene aggiornata l’icona della JLabel con il frame successivo tra quelli 
impostati o con il primo, se l’attuale è l’ultimo. Al termine dell’esecuzione dell’animazione viene reimpostato il 
frame iniziale della label e viene continuato lo scenario tramite la chiamata al metodo continueScenario della classe 
GameManager.

Nota: è richiesto che la lista di frames dati all’animazione contenga in posizione zero il frame iniziale della label 
e dalla posizione uno in poi tutti i frame che devono alternarsi.

Utilizzi:
- Movimenti dei GamePiece sullo schermo

#### 2.9.4 PerpetualAnimation
Una PerpetualAnimation è un’animazione perpetua di una JLabel. l’animazione data dal susseguirsi dei frames impostati 
viene ripetuta finché un evento esterno non la ferma. È possibile settare le stesse impostazioni della superclasse 
(StillAnimation), nonché l’icona da impostare alla label animata al momento in cui l’animazione viene interrotta.
Vi è uno static factory per creare PerpetualAnimation che si interrompono automaticamente non appena cambia lo stato 
di gioco (ovvero si imposta uno stato di gioco in cui l’animazione è attiva). Cambiato lo stato di gioco, se si ritorna 
nello stesso stato, l’animazione si è comunque conclusa e non ripartirà. In modo simile rispetto alla superclasse, 
mette a disposizione delle factory per creare animazioni personalizzate fornendo spritesheet e json seguendo la stessa 
sintassi.

Quindi l’esecuzione dell’animazione non prevede il cambio di stato, ma prevede un ciclo while-true che avvolge 
un’iterazione simile a quella che coinvolge stillAnimation, con la differenza che una chiamata esterna al metodo “stop” 
farà sì che il thread esca dal ciclo.

Alla terminazione verrà eseguito il runnable impostato, ma non viene mandato avanti lo scenario.

Utilizzi:
- Quando viene aggiunto un GamePiece sullo schermo, se questo possiede un’animazione perpetua allora questa viene 
creata ed eseguita.
- Per le animazioni di dialogo dei personaggi, interrotte quando il dialogo viene mandato avanti dal giocatore
- Nel titolo della schermata iniziale del gioco
- Nella creazione di animazioni personalizzate sui GamePiece.













## 2.... XML
I dati su tutti gli oggetti esistenti nel gioco sono presenti nel file oggetti.xml, questo file ha come root-tag 
oggetti all’interno del quale ci sono nodi xml con tag oggetto e attributo nome = nome dell’oggetto.
I dati degli oggetti sono descritti con i tag:
- \<classe>: Classe effettiva dell’oggetto
- \<descrizione>: Descrizione
- \<canUse>: true se l’eventuale azione dell’oggetto è abilitata, false altrimenti
- \<onUse>: contiene a sua volta i tag
  - \<actionName>: nome dell’azione personalizzata
  - \<useScenario state = “nameState”>: path dello scenario da eseguire quando l’oggetto viene usato (si clicca il 
  tasto corrispondente all’azione nel menu contestuale, o quando l’oggetto è nell’inventario, è selezionato e si clicca 
  sul giocatore).

Nota: ci possono essere più tag <useScenario> per associare comportamenti diversi a seconda dello stato.

- \<animazionePerpetuaPng>: path dello spritesheet dell’animazione perpetua dell’oggetto
- \<animazionePerpetuaJson>: path del file json relativo all’animazione perpetua dell’oggetto
- \<onUseWith>: contiene a sua volta i tag
  - \<keep>: se l’oggetto deve essere mantenuto nell’inventario dopo l’interazione useWith
  - \<target>: GamePiece target dell’interazione useWith
  - \<targetInitState>: è lo stato in cui deve trovarsi il target affinché l’interazione avvenga, quindi lo scenario venga eseguito
  - \<targetFinalState>: lo stato in cui viene impostato il target alla fine dello scenario
  - \<scenario>: path dello scenario associato all’interazione
- \<onOpen>: che a sua volta contiene i tag:
  - \<Scenario state = “nameState”>: path dello scenario da eseguire quando si chiama il metodo open

## XML dei personaggi
Questo file ha come root-tag “personaggi”, all’interno del quale ci sono nodi xml con tag “personaggio” e attributo 
“nome=nome personaggio”. I tag possibili sono:
- \<spriteSheet>: path dello sprite sheet o dello sprite del personaggio
- \<json>: (opzionale) path del json corrispondente allo spritesheet
- \<speakScenarios>: che a sua volta contiene i tag
  - \<sentence state = “nameState”>: frase da pronunciare all’interazione “parla”
  - \<scenario state= “nameState”>: path dello scenario da eseguire all’interazione “parla”
  
Di questi ultimi due tag ce ne possono essere in numero arbitrario, purché non ce ne siano due con lo stesso attributo
associato al valore “state”.

